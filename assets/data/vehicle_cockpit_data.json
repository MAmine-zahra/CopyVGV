{
  "mainTitle": "Vehicle Cockpit",
  "content": [
    {
      "type": "text",
      "text": "The Vehicle Cockpit simulates a realtime speedometer and tachometer as the user accelerates around the track."
    },
    {
      "type": "image",
      "image": "assets/images/vehicle_cockpit.png"
    },
    {
      "type": "text",
      "text": "The source code for this project is available on GitHub. To view the live demo, click here."
    },
    {
      "type": "subtitle",
      "text": "Flame"
    },
    {
      "type": "text",
      "text": "Flame is a game engine that is built for Flutter. It is used to render and update our gauge. Let’s take a deeper look into how the components that make up the gauge are created and composed together to form a working speedometer and tachometer."
    },
    {
      "type": "image",
      "image": "assets/images/speedometer.png"
    },
    {
      "type": "subtitle",
      "text": "GaugeGame"
    },
    {
      "type": "text",
      "text":"The GaugeGame is the FlameGame object. All of the components that make up the gauge are added inside of the onLoad method. These components include the GaugeComponent, Speedometer, and the Gear."
    },
    {
      "type": "code",
      "code": "  @override\n  Future<void> onLoad() async {\n    await add(\n      gauge = GaugeComponent(\n        size: Vector2.all(340),\n        position: size / 2,\n        maxRpm: (sim.vehicle.engineRpmMaximum / 1000).round(),\n        dangerZone: (sim.vehicle.engineRpmRedline / 1000).round(),\n        appTheme: appTheme,\n      ),\n    );\n\n    await add(\n      speedometer = Speedometer(\n        speed: 0,\n        position: size / 2 - Vector2(0, 40),\n      ),\n    );\n\n    await add(\n      gear = Gear(\n        position: size / 2 + Vector2(0, 30),\n        triangleSize: 60,\n      ),\n    );\n  }"
    },
    {
      "type": "text",
      "text": "Not only does the GaugeGame add the components to be displayed, it also handles the user input to update the game. As you’ll see below, the GaugeGame can directly call methods on its components, and can also make its variables and methods available to its children.\n\nThe GaugeGame relies on a GameLoop to update the components on the screen. This calls the update method where we can update the gauge’s progress, speedometer, and current gear."
    },
    {
      "type": "code",
      "code": "  @override\n  void update(double dt) {\n    sim.simulate(dt * timeScale, hittingGas ? 1.0 : -1.3);\n\n    gauge.setProgress(\n      sim.engineRpm / sim.vehicle.engineRpmMaximum,\n      dt,\n    );\n    speedometer.speed = sim.speed;\n    gear.gearText.text = sim.gear.toString();\n\n    onSpeedChanged(sim.speed);\n\n    super.update(dt);\n  }"
    },
    {
      "type": "text",
      "text": "The GaugeComponent is a PositionComponent that composes GaugeRing and the components that are needed to display the vehicle’s RPM information: GaugeProgress and GaugeRpmNumbers. These are added in the GaugeComponent’s onLoad method:"
    },
    {
      "type": "code",
      "code": "  @override\n  Future<void> onLoad() async {\n    await add(\n      GaugeRing(\n        size: size.clone(),\n        color: appTheme.colorScheme.error,\n      ),\n    );\n\n    const offset = 16.0;\n    final innerRingPosition = Vector2.all(offset / 2);\n    final innerRingSize = size.clone() - Vector2.all(offset);\n    await add(\n      GaugeProgress(\n        position: innerRingPosition,\n        size: innerRingSize,\n      ),\n    );\n    await add(\n      GaugeRpmNumbers(\n        position: innerRingPosition,\n        size: innerRingSize,\n      ),\n    );\n  }"
    },
    {
      "type": "subtitle",
      "text": "Gauge Ring"
    },
    {
      "type": "text",
      "text": "The GaugeRing is a PositionComponent that forms the outline of the gauge. This component simply renders the ring."
    },
    {
      "type": "image",
      "image": "assets/images/gauge_ring.png"
    },
    {
      "type": "subtitle",
      "text": "Gauge Progress"
    },
    {
      "type": "text",
      "text": "The GaugeProgress is another PositionComponent object that draws the gradient RPM progress bar that is located just inside of the GaugeRing. The GaugeComponent’s progress value gets set within the GaugeGame’s update method. The GaugeProgress object makes use of the ParentIsA mixin, which gives the component access to the parent component via the parent property."
    },
    {
      "type": "image",
      "image": "assets/images/gauge_progress.png"
    },
    {
      "type": "subtitle",
      "text": "Gauge RPM Numbers"
    },
    {
      "type": "text",
      "text": "The GaugeRpmNumbers is the last PositionComponent object that is used for the tachometer. This component consist of the GaugeRmpPoint component, that draws the RPM tick marks, and also the GaugeNumberIndicator that draws the RPM numbers below the ticks."
    },
    {
      "type": "image",
      "image": "assets/images/gauge_rpm_numbers.png"
    },
    {
      "type": "subtitle",
      "text": "Speedometer"
    },
    {
      "type": "text",
      "text": "The Speedometer is a TextComponent object that renders the current speed and the “MPH” label to the screen. The Speedometer object uses the HasGameRef<GaugeGame> mixin, which allows it to access variables and methods that are in the GaugeGame class. This makes it easier for the Speedometer to access the GaugeGame’s appTheme and l10n members."
    },
    {
      "type": "image",
      "image": "assets/images/gauge_speed.png"
    },
    {
      "type": "subtitle",
      "text": "Gear"
    },
    {
      "type": "text",
      "text": "The Gear is a PositionComponent that renders the vehicle’s current gear inside of a triangle. The gearText is set directly in the GaugeGame."
    },
    {
      "type": "code",
      "code": "gear.gearText.text = sim.gear.toString();"
    },
    {
      "type": "image",
      "image": "assets/images/gauge_gear.png"
    },
    {
      "type": "subtitle",
      "text": "Adding the Gauge to the Widget Tree"
    },
    {
      "type": "text",
      "text": "To add the gauge to the DashboardPage, we’ll use Flame’s GameWidget. The GameWidget requires a Game object. In this case, that would be our GaugeGame."
    },
    {
      "type": "code",
      "code": "final game = GaugeGame(\n  sim: VehicleSim(vehicle: Vehicles.compactCrossoverSUV),\n  appTheme: theme,\n  l10n: l10n,\n  onSpeedChanged: onSpeedChanged,\n);\n\n// ...\n\nLayoutBuilder(\n  builder: (context, constraints) {\n    final width = min<double>(400, constraints.maxWidth);\n    return SizedBox.square(\n      dimension: width * .75,\n      child: Transform.scale(\n        scale: width / 500,\n        child: GameWidget(\n          game: game,\n        ),\n      ),\n    );\n  },\n),"
    },
    {
      "type": "text",
      "text": "The acceleratorPedalPushed() and acceleratorPedalReleased() can be called on the game object to simulate pressing and releasing the accelerator pedal."
    }
  ]
}