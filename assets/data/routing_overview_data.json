{
  "mainTitle": "Routing Overview",
  "content": [
    {
      "type": "text",
      "text": "Navigation is a crucial component of any app. A declarative routing structure is essential for building scalable apps that function seamlessly on both mobile and web platforms. At VGV, we recommend using the GoRouter package for handling navigation needs, as it provides a robust and flexible solution for managing routes."
    },
    {
      "type": "subtitle",
      "text": "GoRouter"
    },
    {
      "type": "text",
      "text": "GoRouter is a popular routing package that is maintained by the Flutter team. It is built on top of the Navigator 2.0 API and reduces much of the boilerplate code that is required for even simple navigation. It is a declarative routing package with a URL-based API that supports parsing path and query parameters, redirection, sub-routes, and multiple navigators. Additionally, GoRouter works well for both mobile and web apps."
    },
    {
      "type": "subtitle",
      "text": "Configuration"
    },
    {
      "type": "text",
      "text": "To enable deep linking in your app (such as redirecting to a login page or other features), routing must be carefully configured to properly support backwards navigation.\n\nStructure your routes in a way that makes logical sense. Avoid placing all of your routes on the root path. Instead, use sub-routes."
    },
    {
      "type": "code2",
      "goodCode": "/\n/flutter\n/flutter/news\n/flutter/chat\n/android\n/android/news\n/android/chat",
      "badCode": "/\n/flutter\n/flutter-news\n/flutter-chat\n/android\n/android-news\n/android-chat"
    },
    {
      "type": "note",
      "note": "Not only does using sub-routes make the path more readable, it also ensures that the app can navigate backwards correctly from the child pages."
    },
    {
      "type": "subtitle",
      "text": "Use type-safe routes"
    },
    {
      "type": "text",
      "text": "GoRouter allows you to define type-safe routes. When routes are type-safe, you no longer have to worry about typos and casting your route’s path and query parameters to the correct type."
    },
    {
      "type": "code2",
      "goodCode": "@TypedGoRoute<CategoriesPageRoute>(\n  name: 'categories',\n  path: '/categories',\n)\n@immutable\nclass CategoriesPageRoute extends GoRouteData {\n  const CategoriesPageRoute({\n    this.size,\n    this.color,\n  });\n\n  final String? size;\n  final String? color;\n\n  @override\n  Widget build(context, state) {\n    return CategoriesPage(\n      size: size,\n      color: color,\n    );\n  }\n}",
      "badCode": "GoRoute(\n  name: 'categories',\n  path: '/categories',\n  builder: (context, state) {\n    final size = state.uri.queryParameters['size'];\n    final color = state.uri.queryParameters['category'];\n    return CategoriesPage(size: size, color: color);\n  }\n)"
    },
    {
      "type": "text",
      "text": "Navigating to the categories page using the type-safe route is as simple as calling:"
    },
    {
      "type": "code",
      "code": "const CategoriesPageRoute(size: 'small', color: 'blue').go(context);"
    },
    {
      "type": "note",
      "note": "When needing to route to a page from a deep link, it is still possible to use the route’s name/path and query parameters. However, using type-safe routes is recommended for navigating within the app. If your deep links are coming from an external source, choose the method that best fits your needs.\n\nFor reasons listed in the Prefer navigating by name over path section below, navigating by name is preferred over navigating by path."
    },
    {
      "type": "code3",
      "declarative": "context.goNamed('categories', queryParameters: {'size': 'small', 'color': 'blue'})",
      "imperative": "context.go('/categories?size=small&color=blue');",
      "decLabel": "Navigating by name",
      "impLabel": "Navigating by path"
    },
    {
      "type": "subtitle",
      "text": "Prefer go over push methods"
    },
    {
      "type": "text",
      "text": "GoRouter offers multiple ways to navigate to a route, such as pushing every route onto the stack and navigating to a route’s path.\n\nWhen possible, use GoRouter’s go methods for navigation. Calling go pushes a new route onto the navigation stack according to your route’s path and updates the path in your browser’s URL address bar (if on web).\n\nUse the push method for navigation when you are expecting to receive data from a route when it is popped. Popping with data is a common scenario when pushing a dialog onto the stack which collects input from the user. Since you will never be expected to route the user directly to the dialog from a deep link, using push prevents the address bar from updating the route."
    },
    {
      "type": "note",
      "note": "It is possible, however, to update the path in the URL address bar when using push by adding the following:\n\n  GoRouter.optionURLReflectsImperativeAPIs = true;\n\nNote that we do not recommend modifying the behavior of push in this way unless you are in the process of migrating to GoRouter 8.0.0.\n\nFor more information on the differences between go and push, read this Code with Andrea article."
    },
    {
      "type": "text",
      "text": "Using go will ensure that the back button in your app’s AppBar will display when the current route has a parent that it can navigate backwards to. Root paths will not display a back button in their AppBar. For example, /flutter/news would display a back arrow in the AppBar to navigate back to /flutter, but /flutter would not not display a back button. Using sub-routes correctly removes the need to manually handle the back button functionality."
    },
    {
      "type": "note",
      "note": "In a Flutter web app, the browser’s back button will still be enabled as long as there are pages on the navigation stack, regardless of the navigation method that is used. Using redirects correctly will help ensure that the back button functions according to your app’s navigation structure."
    },
    {
      "type": "subtitle",
      "text": "Use hyphens for separating words in a URL"
    },
    {
      "type": "text",
      "text": "Mobile app users will likely never see your route’s path, but web app users can easily view it in the browser’s URL address bar. Your routing structure should be consistent and defined with the web in mind. Not only does this make your paths easier to read, it allows you the option of deploying your mobile app to the web without any routing changes needed."
    },
    {
      "type": "code2",
      "goodCode": "/user/update-address",
      "badCode": "/user/update_address\n/user/updateAddress"
    },
    {
      "type": "note",
      "note": "For a full list of URL structure best practices, take a look at this document from Google."
    },
    {
      "type": "subtitle",
      "text": "Prefer navigating by name over path"
    },
    {
      "type": "text",
      "text": "If you’re using GoRoute’s type-safe routes, navigate using the go extension method that was generated for your route."
    },
    {
      "type": "code",
      "code": "FlutterNewsPageRoute().go(context);"
    },
    {
      "type": "text",
      "text": "If a route to a page is given to you from an external source, such as a push notification, to deep link to a specific page within your app, GoRouter allows you to navigate to a route by its name or by its path.\n\nBecause your app’s structure and paths can change over time, we recommend routing by name to avoid potential issues of a route’s path getting out of sync.\n\nConsider this situation: An app has a route defined with the path /flutter-news for the FlutterNewsPage."
    },
    {
      "type": "code",
      "code": "@TypedGoRoute<FlutterNewsPageRoute>(\n  name: 'flutterNews',\n  path: '/flutter-news',\n)\n@immutable\nclass FlutterNewsPageRoute extends GoRouteData {\n  @override\n  Widget build(context, state) {\n    return const FlutterNewsPage();\n  }\n}"
    },
    {
      "type": "text",
      "text": "Later, the pages in the app were reorganized and the path to the FlutterNewsPage has changed."
    },
    {
      "type": "code",
      "code": "@TypedGoRoute<TechnologyPageRoute>(\n  name: 'technology',\n  path: '/technology',\n  routes: [\n    TypedGoRoute<FlutterPageRoute>(\n      name: 'flutter',\n      path: 'flutter',\n      routes: [\n        TypedGoRoute<FlutterNewsPageRoute>(\n          name: 'flutterNews',\n          path: 'news',\n        ),\n      ],\n    ),\n  ],\n)"
    },
    {
      "type": "text",
      "text": "If the app was relying on the path to navigate the user to the FlutterNewsPage and the deep link path from the external source didn’t match the route’s path, the route would not be found. However, when relying on the route name, navigation would work in either situation."
    },
    {
      "type": "subtitle",
      "text": "Extension methods"
    },
    {
      "type": "text",
      "text": "GoRouter provides extension methods on BuildContext to simplify navigation. For consistency, use the extension method over the longer GoRouter methods since they are functionally equivalent."
    },
    {
      "type": "code2",
      "goodCode": "context.goNamed('flutterNews');",
      "badCode": "GoRouter.of(context).goNamed('flutterNews');"
    },
    {
      "type": "subtitle",
      "text": "Navigating with parameters"
    },
    {
      "type": "text",
      "text": "Many times when navigating, you need to pass data from one page to another. GoRouter makes this easy by providing multiple ways to accomplish this: path parameters, query parameters, and an extra parameter."
    },
    {
      "type": "subtitle",
      "text": "Path parameters"
    },
    {
      "type": "text",
      "text": "Use path parameters when identifying a specific resource."
    },
    {
      "type": "code",
      "code": "/article/whats-new-in-flutter"
    },
    {
      "type": "text",
      "text": "To navigate to the details page of a particular article, the GoRoute would look like this:"
    },
    {
      "type": "code",
      "code": "// ...\n@TypedGoRoute<FlutterArticlePageRoute>(\n  name: 'flutterArticle',\n  path: 'article/:id',\n)\n@immutable\nclass FlutterArticlePageRoute extends GoRouteData {\n  const FlutterArticlePageRoute({\n    required this.id,\n  });\n\n  final String id;\n\n  @override\n  Widget build(context, state) {\n    return FlutterArticlePage(id: id);\n  }\n}\n// ..."
    },
    {
      "type": "text",
      "text": "Navigating to that page with the article id is as simple as providing the article id to the FlutterArticlePageRoute’s constructor:"
    },
    {
      "type": "code",
      "code": "FlutterArticlePageRoute(id: article.id).go(context);"
    },
    {
      "type": "subtitle",
      "text": "Query parameters"
    },
    {
      "type": "text",
      "text": "Use query parameters when filtering or sorting resources."
    },
    {
      "type": "code",
      "code": "/flutter/articles?date=07162024&category=all"
    },
    {
      "type": "text",
      "text": "To navigate to a page of filtered articles, the GoRoute would look like this:"
    },
    {
      "type": "code",
      "code": "// ...\n@TypedGoRoute<FlutterArticlesPageRoute>(\n  name: 'flutterArticles',\n  path: 'articles',\n)\n@immutable\nclass FlutterArticlesPageRoute extends GoRouteData {\n  const FlutterArticlesPageRoute({\n    this.date,\n    this.category,\n  });\n\n  final String? date;\n  final String? category;\n\n  @override\n  Widget build(context, state) {\n    return FlutterArticlesPage(\n      date: date,\n      category: category,\n    );\n  }\n}\n// ..."
    },
    {
      "type": "note",
      "note": "Unlike path parameters, query parameters do not have to be defined in your route path."
    },
    {
      "type": "text",
      "text": "To navigate to the list of filtered articles:"
    },
    {
      "type": "code",
      "code": "FlutterArticlesPageRoute(date: state.date, category: state.category).go(context);"
    },
    {
      "type": "subtitle",
      "text": "Extra parameter"
    },
    {
      "type": "text",
      "text": "GoRouter has the ability to pass objects from one page to another. Most of the time, however, we avoid using the extra object when navigating to a new route."
    },
    {
      "type": "caution",
      "caution": "The extra option used during navigation does not work on the web and cannot be used for deep linking, so we do not recommend using it."
    },
    {
      "type": "code2",
      "badCode": "@TypedGoRoute<FlutterArticlePageRoute>(\n  name: 'flutterArticle',\n  path: 'article',\n)\n@immutable\nclass FlutterArticlePageRoute extends GoRouteData {\n  const FlutterArticlePageRoute({\n    required this.article,\n  });\n\n  final Article article;\n\n  @override\n  Widget build(context, state) {\n    return FlutterArticlePage(article: article);\n  }\n}"
    },
    {
      "type": "code",
      "code": "FlutterArticlePageRoute(article: article).go(context);"
    },
    {
      "type": "text",
      "text": "In this example, we are passing the article object to the article details page. If your app is designed to only work on mobile and there are no plans of deep linking to the articles details page, then this is fine. But, if the requirements change and now you want to support the web or deep link users directly to the details of a particular article, changes will need to be made. Instead, pass the identifier of the article as a path parameter and fetch the article information from inside of your article details page."
    },
    {
      "type": "code2",
      "goodCode": "FlutterArticlePageRoute(id: state.article.id).go(context);"
    },
    {
      "type": "code",
      "code": "@TypedGoRoute<FlutterArticlePageRoute>(\n  name: 'flutterArticle',\n  path: 'article/:id',\n)\n@immutable\nclass FlutterArticlePageRoute extends GoRouteData {\n  const CategoriesPageRoute({\n    required this.id,\n  });\n\n  final String id;\n\n  @override\n  Widget build(context, state) {\n    return FlutterArticlePage(id: id);\n  }\n}"
    },
    {
      "type": "note",
      "note": "This does not necessarily mean that you have to make another network request to fetch the article information if you already have it. You may need to refactor your repository layer to retrieve the article information from the cache if the data has already been fetched, otherwise make the request to fetch the article information."
    },
    {
      "type": "subtitle",
      "text": "Redirects"
    },
    {
      "type": "text",
      "text": "Sometimes you need to redirect users to a different location in the app. For example: only signed-in users can access parts of your app. If the user isn’t signed-in, you want to redirect the user to the sign in page. Fortunately, GoRouter makes this very easy and redirects can be done at the root and sub-route level."
    },
    {
      "type": "code",
      "code": "class AppRouter {\n  AppRouter({\n    required GlobalKey<NavigatorState> navigatorKey,\n  }) {\n    _goRouter = _routes(\n      navigatorKey,\n    );\n  }\n\n  late final GoRouter _goRouter;\n\n  GoRouter get routes => _goRouter;\n\n  GoRouter _routes(\n    GlobalKey<NavigatorState> navigatorKey,\n  ) {\n    return GoRouter(\n      initialLocation: '/',\n      navigatorKey: navigatorKey,\n      redirect: (context, state) {\n        final status == context.read<AppBloc>().state.status;\n\n        if (status == AppStatus.unauthenticated) {\n          return SignInPageRoute().location;\n        }\n\n        return null;\n      },\n      routes: $appRoutes,\n    )\n  }\n}"
    },
    {
      "type": "code",
      "code": "@TypedGoRoute<HomePageRoute>(\n  name: 'home',\n  path: '/',\n)\n@immutable\nclass HomePageRoute extends GoRouteData {\n  const HomePageRoute();\n\n  @override\n  Widget build(context, state) {\n    return HomePage();\n  }\n}\n\n@TypedGoRoute<SignInPageRoute>(\n  name: 'signIn',\n  path: '/sign-in',\n)\n@immutable\nclass SignInPageRoute extends GoRouteData {\n  const SignInPageRoute();\n\n  @override\n  Widget build(context, state) {\n    return SignInPage();\n  }\n}"
    },
    {
      "type": "note",
      "note": "Redirects on the parent routes are executed first. This is another reason why it is important to organize your URL hierarchy in a way where one redirect on a parent route can apply to all of the sub-routes."
    },
    {
      "type": "text",
      "text": "In this example, the user is redirected to the restricted page if the user’s status isn’t premium and tries to access /premium, /premium/show, or /premium/merch. Having shows and merch as sub-routes avoids having to add redirect logic to each route."
    },
    {
      "type": "code",
      "code": "@TypedGoRoute<PremiumPageRoute>(\n  name: 'premium',\n  path: '/premium',\n  routes: [\n    TypedGoRoute<PremiumShowsPageRoute>(\n      name: 'premiumShows',\n      path: 'shows',\n    ),\n    TypedGoRoute<PremiumMerchPageRoute>(\n      name: 'premiumMerch',\n      path: 'merch',\n    ),\n  ],\n)\n@immutable\nclass PremiumPageRoute extends GoRouteData {\n  const PremiumPageRoute();\n\n  @override\n  Widget build(context, state) {\n    return PremiumPage();\n  }\n\n  @override\n  String? redirect(context, state) {\n    final status == context.read<AppBloc>().state.user.status;\n\n    if (status != UserStatus.premium) {\n      return RestrictedPageRoute().location;\n    }\n\n    return null;\n  }\n}\n\n@immutable\nclass PremiumShowsPageRoute extends GoRouteData {\n  const PremiumShowsPageRoute();\n\n  @override\n  Widget build(context, state) {\n    return PremiumShowsPage();\n  }\n}\n\n@immutable\nclass PremiumMerchPageRoute extends GoRouteData {\n  const PremiumMerchPageRoute();\n\n  @override\n  Widget build(context, state) {\n    return PremiumMerchPage();\n  }\n}\n\n@TypedGoRoute<RestrictedPageRoute>(\n  name: 'restricted',\n  path: '/restricted',\n)\n@immutable\nclass RestrictedPageRoute extends GoRouteData {\n  const RestrictedPageRoute();\n\n  @override\n  Widget build(context, state) {\n    return RestrictedPage();\n  }\n}"
    }
  ]
}