{
  "mainTitle": "Code Style",
  "content": [
    {
      "type": "text",
      "text": "In general, the best guides for code style are the Effective Dart guidelines and the linter rules set up in very_good_analysis. However, there are certain practices weâ€™ve learned outside of these two places that will make code more maintainable."
    },
    {
      "type": "subtitle",
      "text": "Record Types"
    },
    {
      "type": "text",
      "text": "Among other things, the release of Dart 3.0 introduced record types, a way to store two different but related pieces of data without creating a separate data class. When using record types, be sure to choose expressive names for positional values."
    },
    {
      "type": "code2",
      "badCode": "Future<(String, String)> getUserNameAndEmail() async => _someApiFetchMethod();\n\nfinal userData = await getUserNameAndEmail();\n\n// a bunch of other code...\n\nif (userData.$1.isValid) {\n  // do stuff\n}"
    },
    {
      "type": "text",
      "text": "The above example will compile, but it is not immediately obvious what value userData.$1 refers to here. The name of the function gives the reader the impression that the second value in the record is the email, but it is not clear. Particularly in a large codebase, where there could be more processing in between the call to getUserNameAndEmail() and the check on userData.$1, reviewers will not be able to tell immediately what is going on here."
    },
    {
      "type": "code2",
      "goodCode": "Future<(String, String)> getUserNameAndEmail() async => _someApiFetchMethod();\n\nfinal (username, email) = await getUserNameAndEmail();\n\n// a bunch of other code...\n\nif (email.isValid) {\n  // do stuff\n}"
    },
    {
      "type": "text",
      "text": "Now, we are expressly naming the values that we are getting from our record type. Any reviewer or future maintainer of this code will know what value is being validated."
    },
    {
      "type": "tip",
      "tip": "While this is our recommended practice for dealing with record types, you might want to consider whether you actually need a record type. Particularly in larger projects where you are using values across multiple files, dedicated data models may be easier to read and maintain."
    }
  ]
}